{"version":3,"sources":["../src/ocean/waveMath.ts"],"names":[],"mappings":";AAEA,IAAM,qBAAA,GAAwB,WAAA;AAO9B,SAAS,OACP,IAAA,EACA,IAAA,EACA,IAAA,EACA,IAAA,EACA,WACA,SAAA,EACc;AACd,EAAA,MAAM,CAAA,GAAA,CAAK,IAAA,GAAO,IAAA,GAAO,IAAA,GAAO,QAAQ,SAAA,GAAY,SAAA;AACpD,EAAA,MAAM,OAAO,IAAA,CAAK,GAAA,CAAI,KAAK,GAAA,CAAI,CAAC,IAAI,CAAG,CAAA;AACvC,EAAA,MAAM,UAAA,GAAa,CAAC,IAAA,GAAO,IAAA,CAAK,IAAI,CAAC,CAAA;AACrC,EAAA,OAAO,EAAE,MAAM,UAAA,EAAW;AAC5B;AAEO,SAAS,gBACd,CAAA,EACA,CAAA,EACA,SACA,MAAA,EACA,OAAA,GAAU,OAAO,mBAAA,EACT;AACR,EAAA,MAAM,eAAe,IAAA,CAAK,GAAA,CAAI,GAAG,IAAA,CAAK,KAAA,CAAM,OAAO,CAAC,CAAA;AACpD,EAAA,IAAI,iBAAiB,CAAA,EAAG;AACtB,IAAA,OAAO,MAAA,CAAO,QAAA;AAAA,EAChB;AAEA,EAAA,IAAI,IAAA,GAAO,CAAA;AACX,EAAA,IAAI,YAAY,MAAA,CAAO,aAAA;AACvB,EAAA,IAAI,iBAAiB,MAAA,CAAO,kBAAA;AAC5B,EAAA,IAAI,MAAA,GAAS,CAAA;AACb,EAAA,IAAI,SAAA,GAAY,CAAA;AAChB,EAAA,IAAI,UAAA,GAAa,CAAA;AACjB,EAAA,IAAI,OAAA,GAAU,CAAA;AACd,EAAA,IAAI,OAAA,GAAU,CAAA;AAEd,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,YAAA,EAAc,KAAK,CAAA,EAAG;AACxC,IAAA,MAAM,UAAA,GAAa,IAAA,CAAK,GAAA,CAAI,IAAA,GAAO,OAAO,iBAAiB,CAAA;AAC3D,IAAA,MAAM,UAAA,GAAa,IAAA,CAAK,GAAA,CAAI,IAAA,GAAO,OAAO,iBAAiB,CAAA;AAC3D,IAAA,MAAM,EAAE,IAAA,EAAM,UAAA,EAAW,GAAI,MAAA;AAAA,MAC3B,OAAA;AAAA,MACA,OAAA;AAAA,MACA,UAAA;AAAA,MACA,UAAA;AAAA,MACA,SAAA;AAAA,MACA,OAAA,GAAU,iBAAiB,MAAA,CAAO;AAAA,KACpC;AAEA,IAAA,OAAA,IAAW,UAAA,GAAa,UAAA,GAAa,MAAA,GAAS,MAAA,CAAO,cAAA;AACrD,IAAA,OAAA,IAAW,UAAA,GAAa,UAAA,GAAa,MAAA,GAAS,MAAA,CAAO,cAAA;AAErD,IAAA,SAAA,IAAa,IAAA,GAAO,MAAA;AACpB,IAAA,UAAA,IAAc,MAAA;AAEd,IAAA,MAAA,IAAU,MAAA,CAAO,WAAA;AACjB,IAAA,SAAA,IAAa,MAAA,CAAO,mBAAA;AACpB,IAAA,cAAA,IAAkB,MAAA,CAAO,oBAAA;AACzB,IAAA,IAAA,IAAQ,qBAAA;AAAA,EACV;AAEA,EAAA,OAAO,UAAA,GAAa,CAAA,GAAI,SAAA,GAAY,UAAA,GAAa,CAAA;AACnD;AASO,SAAS,iBACd,CAAA,EACA,CAAA,EACA,SACA,MAAA,EACA,OAAA,GAAU,OAAO,mBAAA,EACT;AACR,EAAA,MAAM,MAAM,eAAA,CAAgB,CAAA,EAAG,CAAA,EAAG,OAAA,EAAS,QAAQ,OAAO,CAAA;AAC1D,EAAA,OAAO,MAAA,CAAO,QAAA,GAAA,CAAY,GAAA,GAAM,MAAA,CAAO,YAAY,MAAA,CAAO,aAAA;AAC5D;AAEO,SAAS,gBAAA,CACd,GACA,CAAA,EACA,OAAA,EACA,QACA,OAAA,GAAU,GAAA,EACV,OAAA,GAAU,MAAA,CAAO,mBAAA,EACS;AAC1B,EAAA,MAAM,IAAI,gBAAA,CAAiB,CAAA,EAAG,CAAA,EAAG,OAAA,EAAS,QAAQ,OAAO,CAAA;AACzD,EAAA,MAAM,KAAK,gBAAA,CAAiB,CAAA,GAAI,SAAS,CAAA,EAAG,OAAA,EAAS,QAAQ,OAAO,CAAA;AACpE,EAAA,MAAM,KAAK,gBAAA,CAAiB,CAAA,EAAG,IAAI,OAAA,EAAS,OAAA,EAAS,QAAQ,OAAO,CAAA;AAEpE,EAAA,MAAM,EAAA,GAA+B,CAAC,OAAA,EAAS,EAAA,GAAK,GAAG,CAAG,CAAA;AAC1D,EAAA,MAAM,EAAA,GAA+B,CAAC,CAAA,EAAK,EAAA,GAAK,GAAG,OAAO,CAAA;AAE1D,EAAA,MAAM,EAAA,GAAK,EAAA,CAAG,CAAC,CAAA,GAAI,EAAA,CAAG,CAAC,CAAA,GAAI,EAAA,CAAG,CAAC,CAAA,GAAI,EAAA,CAAG,CAAC,CAAA;AACvC,EAAA,MAAM,EAAA,GAAK,EAAA,CAAG,CAAC,CAAA,GAAI,EAAA,CAAG,CAAC,CAAA,GAAI,EAAA,CAAG,CAAC,CAAA,GAAI,EAAA,CAAG,CAAC,CAAA;AACvC,EAAA,MAAM,EAAA,GAAK,EAAA,CAAG,CAAC,CAAA,GAAI,EAAA,CAAG,CAAC,CAAA,GAAI,EAAA,CAAG,CAAC,CAAA,GAAI,EAAA,CAAG,CAAC,CAAA;AACvC,EAAA,MAAM,SAAS,IAAA,CAAK,KAAA,CAAM,EAAA,EAAI,EAAA,EAAI,EAAE,CAAA,IAAK,CAAA;AACzC,EAAA,OAAO,CAAC,EAAA,GAAK,MAAA,EAAQ,EAAA,GAAK,MAAA,EAAQ,KAAK,MAAM,CAAA;AAC/C","file":"chunk-IT73NM3N.js","sourcesContent":["import type { WaveSamplingParams } from \"./types\";\n\nconst OCTAVE_DIRECTION_STEP = 1232.399963;\n\ninterface WaveDxResult {\n  wave: number;\n  derivative: number;\n}\n\nfunction waveDx(\n  posX: number,\n  posZ: number,\n  dirX: number,\n  dirZ: number,\n  frequency: number,\n  timeShift: number\n): WaveDxResult {\n  const x = (dirX * posX + dirZ * posZ) * frequency + timeShift;\n  const wave = Math.exp(Math.sin(x) - 1.0);\n  const derivative = -wave * Math.cos(x);\n  return { wave, derivative };\n}\n\nexport function sampleWaveValue(\n  x: number,\n  z: number,\n  timeSec: number,\n  params: WaveSamplingParams,\n  octaves = params.displacementOctaves\n): number {\n  const totalOctaves = Math.max(0, Math.floor(octaves));\n  if (totalOctaves === 0) {\n    return params.waveMean;\n  }\n\n  let iter = 0.0;\n  let frequency = params.baseFrequency;\n  let timeMultiplier = params.baseTimeMultiplier;\n  let weight = 1.0;\n  let sumValues = 0.0;\n  let sumWeights = 0.0;\n  let sampleX = x;\n  let sampleZ = z;\n\n  for (let i = 0; i < totalOctaves; i += 1) {\n    const directionX = Math.sin(iter + params.waveDirectionSeed);\n    const directionZ = Math.cos(iter + params.waveDirectionSeed);\n    const { wave, derivative } = waveDx(\n      sampleX,\n      sampleZ,\n      directionX,\n      directionZ,\n      frequency,\n      timeSec * timeMultiplier + params.phaseOffset\n    );\n\n    sampleX += directionX * derivative * weight * params.dragMultiplier;\n    sampleZ += directionZ * derivative * weight * params.dragMultiplier;\n\n    sumValues += wave * weight;\n    sumWeights += weight;\n\n    weight *= params.weightDecay;\n    frequency *= params.frequencyMultiplier;\n    timeMultiplier *= params.timeMultiplierGrowth;\n    iter += OCTAVE_DIRECTION_STEP;\n  }\n\n  return sumWeights > 0 ? sumValues / sumWeights : 0.0;\n}\n\n/**\n * SERVER_BUOYANCY_API: deterministic, headless wave height sampler for server physics.\n *\n * This function is intentionally pure math and has no rendering dependency.\n * Given world-space (x, z), simulation time, and shared wave params, it returns\n * a world-space water height that can be used for buoyancy, swimming, and auth logic.\n */\nexport function sampleWaveHeight(\n  x: number,\n  z: number,\n  timeSec: number,\n  params: WaveSamplingParams,\n  octaves = params.displacementOctaves\n): number {\n  const raw = sampleWaveValue(x, z, timeSec, params, octaves);\n  return params.seaLevel + (raw - params.waveMean) * params.waveAmplitude;\n}\n\nexport function sampleWaveNormal(\n  x: number,\n  z: number,\n  timeSec: number,\n  params: WaveSamplingParams,\n  epsilon = 0.1,\n  octaves = params.displacementOctaves\n): [number, number, number] {\n  const h = sampleWaveHeight(x, z, timeSec, params, octaves);\n  const hx = sampleWaveHeight(x + epsilon, z, timeSec, params, octaves);\n  const hz = sampleWaveHeight(x, z + epsilon, timeSec, params, octaves);\n\n  const dx: [number, number, number] = [epsilon, hx - h, 0.0];\n  const dz: [number, number, number] = [0.0, hz - h, epsilon];\n\n  const nx = dz[1] * dx[2] - dz[2] * dx[1];\n  const ny = dz[2] * dx[0] - dz[0] * dx[2];\n  const nz = dz[0] * dx[1] - dz[1] * dx[0];\n  const length = Math.hypot(nx, ny, nz) || 1.0;\n  return [nx / length, ny / length, nz / length];\n}\n"]}
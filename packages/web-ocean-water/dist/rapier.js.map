{"version":3,"sources":["../src/lib/RapierBuoyancy.ts"],"names":[],"mappings":"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","file":"rapier.js","sourcesContent":["import type { RigidBody } from \"@dimforge/rapier3d-compat\";\nimport { sampleWaveHeight, sampleWaveNormal } from \"../ocean/waveMath\";\nimport type { WaveSamplingParams } from \"./settings\";\n\nexport interface BuoyancyProbe {\n  x: number;\n  y: number;\n  z: number;\n  weight?: number;\n}\n\nexport interface RapierBuoyancyConfig {\n  fluidDensity?: number;\n  gravity?: number;\n  volume?: number;\n  maxSubmergenceDepth?: number;\n  buoyancyScale?: number;\n  linearDrag?: number;\n  angularDrag?: number;\n  normalAlign?: number;\n  normalSampleEpsilon?: number;\n}\n\nexport interface BuoyancyApplicationStats {\n  submergedProbeCount: number;\n  submergedFraction: number;\n}\n\nconst DEFAULT_CONFIG: Required<RapierBuoyancyConfig> = {\n  fluidDensity: 1.0,\n  gravity: 9.81,\n  volume: 1.0,\n  maxSubmergenceDepth: 1.0,\n  buoyancyScale: 1.0,\n  linearDrag: 2.4,\n  angularDrag: 1.2,\n  normalAlign: 0.0,\n  normalSampleEpsilon: 0.2\n};\n\nfunction rotateVectorByQuaternion(\n  x: number,\n  y: number,\n  z: number,\n  qx: number,\n  qy: number,\n  qz: number,\n  qw: number\n): { x: number; y: number; z: number } {\n  const tx = 2.0 * (qy * z - qz * y);\n  const ty = 2.0 * (qz * x - qx * z);\n  const tz = 2.0 * (qx * y - qy * x);\n\n  return {\n    x: x + qw * tx + (qy * tz - qz * ty),\n    y: y + qw * ty + (qz * tx - qx * tz),\n    z: z + qw * tz + (qx * ty - qy * tx)\n  };\n}\n\nfunction resolveConfig(config?: RapierBuoyancyConfig): Required<RapierBuoyancyConfig> {\n  return {\n    ...DEFAULT_CONFIG,\n    ...(config ?? {})\n  };\n}\n\nfunction normalizeOrUp(x: number, y: number, z: number): { x: number; y: number; z: number } {\n  const length = Math.hypot(x, y, z);\n  if (!Number.isFinite(length) || length <= 1e-8) {\n    return { x: 0, y: 1, z: 0 };\n  }\n  return { x: x / length, y: y / length, z: z / length };\n}\n\nexport function createBoxBuoyancyProbes(\n  width: number,\n  height: number,\n  depth: number,\n  subdivisions = 2\n): BuoyancyProbe[] {\n  const divisions = Math.max(1, Math.floor(subdivisions));\n  const points: BuoyancyProbe[] = [];\n  const halfX = width * 0.5;\n  const halfY = height * 0.5;\n  const halfZ = depth * 0.5;\n\n  for (let ix = 0; ix <= divisions; ix += 1) {\n    for (let iy = 0; iy <= divisions; iy += 1) {\n      for (let iz = 0; iz <= divisions; iz += 1) {\n        const tx = ix / divisions;\n        const ty = iy / divisions;\n        const tz = iz / divisions;\n        points.push({\n          x: -halfX + tx * width,\n          y: -halfY + ty * height,\n          z: -halfZ + tz * depth,\n          weight: 1\n        });\n      }\n    }\n  }\n\n  return points;\n}\n\nexport function applyBuoyancyToRigidBody(\n  body: RigidBody,\n  probes: readonly BuoyancyProbe[],\n  waveParams: WaveSamplingParams,\n  timeSec: number,\n  dtSec: number,\n  config?: RapierBuoyancyConfig\n): BuoyancyApplicationStats {\n  if (probes.length === 0 || dtSec <= 0 || !Number.isFinite(dtSec)) {\n    return { submergedProbeCount: 0, submergedFraction: 0 };\n  }\n\n  const cfg = resolveConfig(config);\n  const normalAlign = Math.max(0, Math.min(1, cfg.normalAlign));\n  const translation = body.translation();\n  const rotation = body.rotation();\n  const weightedProbeCount = probes.reduce((sum, probe) => sum + Math.max(0, probe.weight ?? 1), 0) || 1.0;\n  const baseProbeVolume = cfg.volume / weightedProbeCount;\n  const maxSubmergence = Math.max(1e-4, cfg.maxSubmergenceDepth);\n  const wakeUp = true;\n\n  let submergedProbeCount = 0;\n  let submergedWeightTotal = 0.0;\n\n  for (const probe of probes) {\n    const probeWeight = Math.max(0, probe.weight ?? 1);\n    if (probeWeight <= 0) {\n      continue;\n    }\n\n    const rotated = rotateVectorByQuaternion(\n      probe.x,\n      probe.y,\n      probe.z,\n      rotation.x,\n      rotation.y,\n      rotation.z,\n      rotation.w\n    );\n\n    const worldPoint = {\n      x: translation.x + rotated.x,\n      y: translation.y + rotated.y,\n      z: translation.z + rotated.z\n    };\n\n    const surfaceHeight = sampleWaveHeight(worldPoint.x, worldPoint.z, timeSec, waveParams);\n    const depth = surfaceHeight - worldPoint.y;\n    if (depth <= 0) {\n      continue;\n    }\n\n    submergedProbeCount += 1;\n    submergedWeightTotal += probeWeight;\n\n    const submergence01 = Math.min(depth / maxSubmergence, 1.0);\n    const displacedVolume = baseProbeVolume * probeWeight * submergence01;\n    const buoyancyMagnitude =\n      cfg.fluidDensity * cfg.gravity * displacedVolume * cfg.buoyancyScale;\n\n    const [nx, ny, nz] = sampleWaveNormal(\n      worldPoint.x,\n      worldPoint.z,\n      timeSec,\n      waveParams,\n      cfg.normalSampleEpsilon\n    );\n    const buoyancyDir = normalizeOrUp(nx * normalAlign, 1 - normalAlign + ny * normalAlign, nz * normalAlign);\n\n    body.applyImpulseAtPoint(\n      {\n        x: buoyancyDir.x * buoyancyMagnitude * dtSec,\n        y: buoyancyDir.y * buoyancyMagnitude * dtSec,\n        z: buoyancyDir.z * buoyancyMagnitude * dtSec\n      },\n      worldPoint,\n      wakeUp\n    );\n\n    const pointVelocity = body.velocityAtPoint(worldPoint);\n    const dragScale = cfg.linearDrag * submergence01;\n    body.applyImpulseAtPoint(\n      {\n        x: -pointVelocity.x * dragScale * dtSec,\n        y: -pointVelocity.y * dragScale * dtSec,\n        z: -pointVelocity.z * dragScale * dtSec\n      },\n      worldPoint,\n      wakeUp\n    );\n  }\n\n  if (submergedProbeCount > 0) {\n    const angVel = body.angvel();\n    const angularDragScale = cfg.angularDrag * (submergedWeightTotal / weightedProbeCount);\n    body.applyTorqueImpulse(\n      {\n        x: -angVel.x * angularDragScale * dtSec,\n        y: -angVel.y * angularDragScale * dtSec,\n        z: -angVel.z * angularDragScale * dtSec\n      },\n      wakeUp\n    );\n  }\n\n  return {\n    submergedProbeCount,\n    submergedFraction: Math.min(1, submergedWeightTotal / weightedProbeCount)\n  };\n}\n"]}
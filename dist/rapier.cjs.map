{"version":3,"sources":["../src/ocean/waveMath.ts","../src/lib/RapierBuoyancy.ts"],"names":[],"mappings":"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","file":"rapier.cjs","sourcesContent":["import type { WaveSamplingParams } from \"./types\";\n\nconst OCTAVE_DIRECTION_STEP = 1232.399963;\n\ninterface WaveDxResult {\n  wave: number;\n  derivative: number;\n}\n\nfunction waveDx(\n  posX: number,\n  posZ: number,\n  dirX: number,\n  dirZ: number,\n  frequency: number,\n  timeShift: number\n): WaveDxResult {\n  const x = (dirX * posX + dirZ * posZ) * frequency + timeShift;\n  const wave = Math.exp(Math.sin(x) - 1.0);\n  const derivative = -wave * Math.cos(x);\n  return { wave, derivative };\n}\n\nexport function sampleWaveValue(\n  x: number,\n  z: number,\n  timeSec: number,\n  params: WaveSamplingParams,\n  octaves = params.displacementOctaves\n): number {\n  const totalOctaves = Math.max(0, Math.floor(octaves));\n  if (totalOctaves === 0) {\n    return params.waveMean;\n  }\n\n  let iter = 0.0;\n  let frequency = params.baseFrequency;\n  let timeMultiplier = params.baseTimeMultiplier;\n  let weight = 1.0;\n  let sumValues = 0.0;\n  let sumWeights = 0.0;\n  let sampleX = x;\n  let sampleZ = z;\n\n  for (let i = 0; i < totalOctaves; i += 1) {\n    const directionX = Math.sin(iter + params.waveDirectionSeed);\n    const directionZ = Math.cos(iter + params.waveDirectionSeed);\n    const { wave, derivative } = waveDx(\n      sampleX,\n      sampleZ,\n      directionX,\n      directionZ,\n      frequency,\n      timeSec * timeMultiplier + params.phaseOffset\n    );\n\n    sampleX += directionX * derivative * weight * params.dragMultiplier;\n    sampleZ += directionZ * derivative * weight * params.dragMultiplier;\n\n    sumValues += wave * weight;\n    sumWeights += weight;\n\n    weight *= params.weightDecay;\n    frequency *= params.frequencyMultiplier;\n    timeMultiplier *= params.timeMultiplierGrowth;\n    iter += OCTAVE_DIRECTION_STEP;\n  }\n\n  return sumWeights > 0 ? sumValues / sumWeights : 0.0;\n}\n\n/**\n * SERVER_BUOYANCY_API: deterministic, headless wave height sampler for server physics.\n *\n * This function is intentionally pure math and has no rendering dependency.\n * Given world-space (x, z), simulation time, and shared wave params, it returns\n * a world-space water height that can be used for buoyancy, swimming, and auth logic.\n */\nexport function sampleWaveHeight(\n  x: number,\n  z: number,\n  timeSec: number,\n  params: WaveSamplingParams,\n  octaves = params.displacementOctaves\n): number {\n  const raw = sampleWaveValue(x, z, timeSec, params, octaves);\n  return params.seaLevel + (raw - params.waveMean) * params.waveAmplitude;\n}\n\nexport function sampleWaveNormal(\n  x: number,\n  z: number,\n  timeSec: number,\n  params: WaveSamplingParams,\n  epsilon = 0.1,\n  octaves = params.displacementOctaves\n): [number, number, number] {\n  const h = sampleWaveHeight(x, z, timeSec, params, octaves);\n  const hx = sampleWaveHeight(x + epsilon, z, timeSec, params, octaves);\n  const hz = sampleWaveHeight(x, z + epsilon, timeSec, params, octaves);\n\n  const dx: [number, number, number] = [epsilon, hx - h, 0.0];\n  const dz: [number, number, number] = [0.0, hz - h, epsilon];\n\n  const nx = dz[1] * dx[2] - dz[2] * dx[1];\n  const ny = dz[2] * dx[0] - dz[0] * dx[2];\n  const nz = dz[0] * dx[1] - dz[1] * dx[0];\n  const length = Math.hypot(nx, ny, nz) || 1.0;\n  return [nx / length, ny / length, nz / length];\n}\n","import type { RigidBody } from \"@dimforge/rapier3d-compat\";\nimport { sampleWaveHeight, sampleWaveNormal } from \"../ocean/waveMath\";\nimport type { WaveSamplingParams } from \"../ocean/types\";\n\nexport interface BuoyancyProbe {\n  x: number;\n  y: number;\n  z: number;\n  weight?: number;\n}\n\nexport interface RapierBuoyancyConfig {\n  fluidDensity?: number;\n  gravity?: number;\n  volume?: number;\n  maxSubmergenceDepth?: number;\n  buoyancyScale?: number;\n  linearDrag?: number;\n  angularDrag?: number;\n  normalAlign?: number;\n  normalSampleEpsilon?: number;\n}\n\nexport interface BuoyancyApplicationStats {\n  submergedProbeCount: number;\n  submergedFraction: number;\n}\n\nconst DEFAULT_CONFIG: Required<RapierBuoyancyConfig> = {\n  fluidDensity: 1.0,\n  gravity: 9.81,\n  volume: 1.0,\n  maxSubmergenceDepth: 1.0,\n  buoyancyScale: 1.0,\n  linearDrag: 2.4,\n  angularDrag: 1.2,\n  normalAlign: 0.35,\n  normalSampleEpsilon: 0.2\n};\n\nfunction rotateVectorByQuaternion(\n  x: number,\n  y: number,\n  z: number,\n  qx: number,\n  qy: number,\n  qz: number,\n  qw: number\n): { x: number; y: number; z: number } {\n  const tx = 2.0 * (qy * z - qz * y);\n  const ty = 2.0 * (qz * x - qx * z);\n  const tz = 2.0 * (qx * y - qy * x);\n\n  return {\n    x: x + qw * tx + (qy * tz - qz * ty),\n    y: y + qw * ty + (qz * tx - qx * tz),\n    z: z + qw * tz + (qx * ty - qy * tx)\n  };\n}\n\nfunction resolveConfig(config?: RapierBuoyancyConfig): Required<RapierBuoyancyConfig> {\n  return {\n    ...DEFAULT_CONFIG,\n    ...(config ?? {})\n  };\n}\n\nexport function createBoxBuoyancyProbes(\n  width: number,\n  height: number,\n  depth: number,\n  subdivisions = 2\n): BuoyancyProbe[] {\n  const divisions = Math.max(1, Math.floor(subdivisions));\n  const points: BuoyancyProbe[] = [];\n  const halfX = width * 0.5;\n  const halfY = height * 0.5;\n  const halfZ = depth * 0.5;\n\n  for (let ix = 0; ix <= divisions; ix += 1) {\n    for (let iy = 0; iy <= divisions; iy += 1) {\n      for (let iz = 0; iz <= divisions; iz += 1) {\n        const tx = ix / divisions;\n        const ty = iy / divisions;\n        const tz = iz / divisions;\n        points.push({\n          x: -halfX + tx * width,\n          y: -halfY + ty * height,\n          z: -halfZ + tz * depth,\n          weight: 1\n        });\n      }\n    }\n  }\n\n  return points;\n}\n\nexport function applyBuoyancyToRigidBody(\n  body: RigidBody,\n  probes: readonly BuoyancyProbe[],\n  waveParams: WaveSamplingParams,\n  timeSec: number,\n  dtSec: number,\n  config?: RapierBuoyancyConfig\n): BuoyancyApplicationStats {\n  if (probes.length === 0 || dtSec <= 0 || !Number.isFinite(dtSec)) {\n    return { submergedProbeCount: 0, submergedFraction: 0 };\n  }\n\n  const cfg = resolveConfig(config);\n  const translation = body.translation();\n  const rotation = body.rotation();\n  const weightedProbeCount = probes.reduce((sum, probe) => sum + Math.max(0, probe.weight ?? 1), 0) || 1.0;\n  const baseProbeVolume = cfg.volume / weightedProbeCount;\n  const maxSubmergence = Math.max(1e-4, cfg.maxSubmergenceDepth);\n  const wakeUp = true;\n\n  let submergedProbeCount = 0;\n  let submergedWeightTotal = 0.0;\n\n  for (const probe of probes) {\n    const probeWeight = Math.max(0, probe.weight ?? 1);\n    if (probeWeight <= 0) {\n      continue;\n    }\n\n    const rotated = rotateVectorByQuaternion(\n      probe.x,\n      probe.y,\n      probe.z,\n      rotation.x,\n      rotation.y,\n      rotation.z,\n      rotation.w\n    );\n\n    const worldPoint = {\n      x: translation.x + rotated.x,\n      y: translation.y + rotated.y,\n      z: translation.z + rotated.z\n    };\n\n    const surfaceHeight = sampleWaveHeight(worldPoint.x, worldPoint.z, timeSec, waveParams);\n    const depth = surfaceHeight - worldPoint.y;\n    if (depth <= 0) {\n      continue;\n    }\n\n    submergedProbeCount += 1;\n    submergedWeightTotal += probeWeight;\n\n    const submergence01 = Math.min(depth / maxSubmergence, 1.0);\n    const displacedVolume = baseProbeVolume * probeWeight * submergence01;\n    const buoyancyMagnitude =\n      cfg.fluidDensity * cfg.gravity * displacedVolume * cfg.buoyancyScale;\n\n    const [nx, ny, nz] = sampleWaveNormal(\n      worldPoint.x,\n      worldPoint.z,\n      timeSec,\n      waveParams,\n      cfg.normalSampleEpsilon\n    );\n    const forceDirX = nx * cfg.normalAlign;\n    const forceDirY = (1 - cfg.normalAlign) + ny * cfg.normalAlign;\n    const forceDirZ = nz * cfg.normalAlign;\n\n    body.addForceAtPoint(\n      {\n        x: forceDirX * buoyancyMagnitude,\n        y: forceDirY * buoyancyMagnitude,\n        z: forceDirZ * buoyancyMagnitude\n      },\n      worldPoint,\n      wakeUp\n    );\n\n    const pointVelocity = body.velocityAtPoint(worldPoint);\n    const dragScale = cfg.linearDrag * submergence01;\n    body.addForceAtPoint(\n      {\n        x: -pointVelocity.x * dragScale,\n        y: -pointVelocity.y * dragScale,\n        z: -pointVelocity.z * dragScale\n      },\n      worldPoint,\n      wakeUp\n    );\n  }\n\n  if (submergedProbeCount > 0) {\n    const angVel = body.angvel();\n    const angularDragScale = cfg.angularDrag * (submergedWeightTotal / weightedProbeCount);\n    body.addTorque(\n      {\n        x: -angVel.x * angularDragScale,\n        y: -angVel.y * angularDragScale,\n        z: -angVel.z * angularDragScale\n      },\n      wakeUp\n    );\n  }\n\n  return {\n    submergedProbeCount,\n    submergedFraction: Math.min(1, submergedWeightTotal / weightedProbeCount)\n  };\n}\n"]}